# Story 4.1.2: Implement GlobalSequenceTrackingToken

## Status: To Do

## Story
- **As a** Developer
- **I want** to create a custom `GlobalSequenceTrackingToken` that uses the `global_sequence_id` from our event store
- **so that** Axon's `TrackingEventProcessor` can efficiently and simply track its progress without complex gap awareness logic.

## Acceptance Criteria
1. A new `GlobalSequenceTrackingToken` class is created that implements Axon's `TrackingToken` interface.
2. The token stores a single `Long` value representing the `global_sequence_id`.
3. The `covers` and `upperBound` methods are implemented correctly for sequence-based comparison.
4. The token is serializable.
5. The `EafPostgresEventStorageEngine` is updated to use and produce this new token type for all streaming reads.

## Tasks / Subtasks

- [ ] **Task 1: Create GlobalSequenceTrackingToken Class** (AC: 1, 2)
  - [ ] Create `GlobalSequenceTrackingToken.kt` in `libs/eaf-eventsourcing-sdk/src/main/kotlin/com/axians/eaf/eventsourcing/axon/token`
  - [ ] Implement `org.axonframework.eventhandling.TrackingToken` interface
  - [ ] Add `globalSequenceId: Long` as primary constructor parameter
  - [ ] Implement data class with proper `equals`, `hashCode`, and `toString` methods

- [ ] **Task 2: Implement TrackingToken Contract Methods** (AC: 3)
  - [ ] Implement `covers(TrackingToken?)` method for sequence-based coverage comparison
  - [ ] Implement `upperBound(TrackingToken?)` method to find the highest sequence boundary
  - [ ] Handle null token cases (when starting from beginning)
  - [ ] Add proper type checking and casting for non-GlobalSequenceTrackingToken instances
  - [ ] Ensure thread-safe immutable implementation

- [ ] **Task 3: Implement Serialization Support** (AC: 4)
  - [ ] Add `@Serializable` annotation with Kotlinx Serialization
  - [ ] Create custom Jackson serializer/deserializer for compatibility
  - [ ] Implement `TokenStore` compatibility for Axon framework persistence
  - [ ] Add JSON schema validation for token format
  - [ ] Test serialization round-trip with various sequence values

- [ ] **Task 4: Token Factory and Utilities**
  - [ ] Create `GlobalSequenceTrackingTokenFactory` for token creation patterns
  - [ ] Implement `createInitialToken()` for starting from sequence 0
  - [ ] Implement `createTokenAt(sequenceId: Long)` for resume scenarios
  - [ ] Add `advanceTo(sequenceId: Long)` method for token progression
  - [ ] Create extension functions for common token operations

- [ ] **Task 5: Integration with EafPostgresEventStorageEngine** (AC: 5)
  - [ ] Update `readEvents(trackingToken, mayBlock)` to handle `GlobalSequenceTrackingToken`
  - [ ] Modify event streaming query to use `global_sequence_id > token.globalSequenceId`
  - [ ] Update `createTailToken()` to return `GlobalSequenceTrackingToken(0)`
  - [ ] Update `createHeadToken()` to return `GlobalSequenceTrackingToken` with max sequence
  - [ ] Ensure all returned `TrackedEventMessage` instances carry the correct token

## Dev Technical Guidance

- **Module Location**: `libs/eaf-eventsourcing-sdk/src/main/kotlin/com/axians/eaf/eventsourcing/axon/token/`
- **Dependencies Required**: Add to `libs/eaf-eventsourcing-sdk/build.gradle.kts`:
  ```kotlin
  implementation(libs.axon.eventsourcing)
  implementation(libs.kotlinx.serialization.json)
  implementation(libs.jackson.module.kotlin)
  ```
- **Axon Framework Integration**: 
  - Token must be compatible with Axon's `TokenStore` for processor resume capability
  - Should integrate seamlessly with `TrackingEventProcessor` and `MultiStreamableMessageSource`
- **Performance Considerations**: 
  - Simple `Long` comparison is much faster than complex gap-aware tokens
  - No need for segment-based tracking in our sequential event store design
  - Optimize for high-throughput event processing scenarios
- **Data Class Pattern**: Use Kotlin data class with immutability for thread safety
- **Serialization Strategy**: 
  - Primary: Kotlinx Serialization for modern Kotlin ecosystem
  - Fallback: Jackson for Spring Boot compatibility
  - Token Store: Custom serializer for Axon's TokenStore persistence
- **Sequence Management**: Must handle edge cases like sequence rollover and initial bootstrap scenarios

## Testing Guidance

- **Objective**: Verify token comparison logic, serialization compatibility, and integration with Axon's tracking infrastructure
- **Key Test Scenarios**:
  - **Unit Tests**:
    - Test `covers()` method with various sequence comparisons (lower, equal, higher)
    - Test `upperBound()` method with multiple token combinations
    - Test null safety in all comparison methods
    - Verify immutability and thread safety
  - **Serialization Tests**:
    - JSON serialization round-trip with various sequence values
    - Jackson compatibility with Spring Boot configurations
    - TokenStore persistence and retrieval scenarios
    - Cross-version compatibility testing
  - **Integration Tests with TrackingEventProcessor**:
    - End-to-end token progression during event streaming
    - Processor resume from persisted token state
    - Multi-processor scenarios with different sequence positions
    - Error recovery and token replay scenarios
- **Performance Tests**:
  - Compare performance against Axon's default `GapAwareTrackingToken`
  - Measure token comparison overhead in high-throughput scenarios
  - Memory usage analysis for token storage
- **Success Criteria**: 
  - All comparison operations complete in <1ms
  - Serialization round-trip maintains exact sequence values
  - Integration tests show seamless processor resume capability
  - Performance improvement over gap-aware tokens is measurable
- **Tools**: JUnit 5, MockK, Axon Test Framework, Kotlinx Serialization Test, JMH for performance testing
