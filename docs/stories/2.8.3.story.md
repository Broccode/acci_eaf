# Story 2.8.3: Implement Production-Grade Security for Pilot Service UI

## Status: Review

## Story

- **As the** Pilot Development Team
- **I want to** refactor the `ticket-management-service` to use a production-grade, **stateless** JWT-based login flow, following the official Vaadin/Hilla security guide
- **so that** the UI is properly secured using EAF and industry best practices for modern SPAs, and we validate this security pattern for future Hilla-based applications.

## Acceptance Criteria (ACs)

1. **Stateless Spring Security Configuration:** The Spring Security configuration (`SecurityConfig.kt`) in the `ticket-management-service` is refactored to use `VaadinWebSecurity.setStatelessAuthentication()`, enabling a JWT-based flow. Session creation is disabled (`SessionCreationPolicy.STATELESS`).
2. **Public Access Configuration:** The login view (`/login`) and any other necessary public resources are explicitly configured to be accessible by unauthenticated users.
3. **Authenticated User Principal Handling:** A backend utility (e.g., `SecurityUtils.java` or equivalent Kotlin) is created to safely retrieve the full `UserDetails` object for an authenticated user from the `Jwt` principal provided in the `SecurityContext`.
4. **User Information Endpoint:** The `@BrowserCallable` Hilla service (`UserInfoService.kt`) is secured. For an authenticated user, it returns essential, non-sensitive user details (e.g., username, roles) by using the new `SecurityUtils` to get user details from the JWT.
5. **Frontend Auth Hook (`useAuth.ts`):** The `useAuth.ts` hook is refactored. It no longer relies on session state but on the presence of a valid user object from `UserInfoService`. It initiates login and handles logout by clearing client-side state and redirecting.
6. **Login View (`LoginView.tsx`):** The `LoginView.tsx` is implemented to use Spring Security's standard form-based login (`/login` POST action). It correctly handles login success (which results in the server setting the JWT cookies) and failure (displaying an error).
7. **Logout Functionality:** A "Sign out" button is available in the main layout for authenticated users. The logout function in the `useAuth` hook clears the client-side authentication state and redirects to the login page. The server-side logout is handled implicitly by the client discarding the token/session info.
8. **Protected Routes:** All application views, except for the login view, are protected. Unauthenticated users attempting to access them are automatically redirected to the `/login` view, enforced by Hilla's integration with Spring Security.
9. **Secret Management:** The JWT signing secret **is not** hardcoded. It is loaded from application properties, and local development properties are excluded from Git.

## Dev Technical Guidance

This story refactors the security model of the `ticket-management-service` from a stateful session-based approach to a modern, **stateless JWT-based** one. This aligns with the [Vaadin/Hilla Stateless Authentication Guide](https://vaadin.com/docs/latest/hilla/guides/security/spring-stateless) and is the preferred pattern for scalable and resilient applications.

### Backend Implementation (`ticket-management-service`)

1. **Dependencies**: Check `apps/ticket-management-service/build.gradle.kts` and ensure `spring-boot-starter-security`, `spring-security-oauth2-jose`, and `spring-security-oauth2-resource-server` dependencies are present.
2. **Security Configuration (`SecurityConfig.kt`)**:
    - **Refactor**: Modify the existing `SecurityConfig.kt`.
    - Set the session creation policy to `SessionCreationPolicy.STATELESS`.
    - Call `setStatelessAuthentication()`, providing a secret key and an issuer string.
    - **CRITICAL:** The secret key **must** be loaded from configuration (`@Value("${my.app.auth.secret}")`) and **not** hardcoded. A 32-byte Base64-encoded secret is required for the `HS256` algorithm.
    - Set the login view with `setLoginView(http, "/login")`.
3. **Secret Key Management**:
    - Add a property like `app.security.auth.secret` to `application.yml`.
    - For local development, create a `apps/ticket-management-service/config/local/application.yml` file with the secret and ensure `**/config/local/` is in `.gitignore`.
    - Use `openssl rand -base64 32` to generate a suitable secret.
4. **Authenticated User Helper (`SecurityUtils.kt`)**:
    - **Create**: In a shared infrastructure package, create a `SecurityUtils.kt` component.
    - It should have one primary method, `getAuthenticatedUser()`, which inspects the `SecurityContext`.
    - If the principal is an instance of `Jwt`, it extracts the username (`subject`) and uses `UserDetailsService` to load the full, real `UserDetails` object. This is crucial for getting roles and other details.
    - It should return an `Optional<UserDetails>`.
5. **User Information Endpoint (`UserInfoService.kt`)**:
    - **Refactor**: Modify the existing `UserInfoService.kt`.
    - Inject the new `SecurityUtils` component.
    - In `getUserInfo()`, call `securityUtils.getAuthenticatedUser()`. If the optional is present, build the `UserInfo` DTO from the `UserDetails` object. Otherwise, return the anonymous user representation.

### Frontend Implementation (`ticket-management-service`)

1. **Authentication Hook (`useAuth.ts`)**:
    - **Refactor**: The `useAuth.ts` hook logic needs to be simplified. Its primary job is to fetch user info and provide a `login` and `logout` function.
    - The hook calls `UserInfoService.getUserInfo()` on load to determine if the user is authenticated (by checking the returned user object).
    - The `login` function in the hook can simply redirect to the `/login` page or be a thin wrapper around the form submission logic.
    - The `logout` function should clear any client-side user state and then redirect to `/login`. Since it's stateless, there is no server endpoint to call; the JWT cookies will be effectively abandoned. Spring Security's `/logout` endpoint may not be relevant in the same way.
2. **Login View (`LoginView.tsx`)**:
    - The implementation remains largely the same, as it posts to a standard Spring Security endpoint.
    - Upon successful login, Spring Security and Hilla will automatically set the JWT cookies. The view should then redirect to a protected route (e.g., `/dashboard`).
3. **Route Protection**:
    - The `ProtectedRoute.tsx` component should be refactored to use the refactored `useAuth` hook. It will gate access based on the hook's state (`authenticated`, `unauthenticated`, `loading`).
    - The primary enforcement remains on the backend via Spring Security, which will reject Hilla calls from unauthenticated users, triggering the client to redirect to login.

## Tasks / Subtasks

- [x] **Task 1: Backend Dependency and Configuration**
  - [x] Add `spring-security-oauth2-jose` and `spring-security-oauth2-resource-server` dependencies.
  - [x] **Refactor** `SecurityConfig.kt` to be stateless, disabling sessions and enabling `setStatelessAuthentication`.
  - [x] Externalize the JWT secret key into `application.yml` and add a local, git-ignored override.
- [x] **Task 2: Backend User Details Retrieval**
  - [x] Create the `SecurityUtils.kt` component to load `UserDetails` from a `Jwt` principal.
  - [x] **Refactor** `UserInfoService.kt` to use `SecurityUtils` for fetching authenticated user data.
  - [x] Write unit/integration tests for the new security configuration and `SecurityUtils`.
- [x] **Task 3: Frontend Authentication Hook**
  - [x] **Refactor** `useAuth.ts` to rely on `UserInfoService` for its state.
  - [x] Implement a client-side `logout` function that clears state and redirects.
- [x] **Task 4: UI and Routing Finalization**
  - [x] Ensure `LoginView.tsx` correctly initiates the login flow.
  - [x] Ensure `ProtectedRoute.tsx` uses the stateless `useAuth` hook correctly.
  - [x] Verify that after a browser refresh on a protected route, the user remains logged in (verifying the JWT cookie mechanism works).
- [ ] **Task 5: E2E Validation**
  - [ ] Manually test the full login flow.
  - [ ] Restart the backend server while logged in on the client; verify that the user remains logged in after the server is back up, confirming statelessness.
  - [ ] Verify role-based UI elements still function correctly based on user data from the JWT.

## Implementation Notes

- The security model has been refactored to a stateless JWT approach, aligning with the Hilla security guide.
- `SecurityConfig.kt` is configured for statelessness.
- `SecurityUtils.kt` correctly extracts user details from a `Jwt` principal and has been adapted for testing.
- The JWT secret is externalized, and local configuration is git-ignored.
- An integration test (`StatelessSecurityIntegrationTest.kt`) has been added to verify the backend security flow.
- The frontend `useAuth.tsx` hook has been corrected and now handles the stateless flow, including logout.
- All relevant import paths have been standardized.

## Blockers

- None

## User sign-off

- Not Complete

## DoD Checklist Report

- Not Started
