# Story 4.1.3: Implement TenantContextHolder for Multi-Tenancy

## Status: To Do

## Story
- **As a** Developer
- **I want** to create a thread-safe `TenantContextHolder` to manage the current tenant's context during event processing
- **so that** I can ensure strict data isolation within the `EventStorageEngine`.

## Acceptance Criteria
1. A new `TenantContextHolder` class is created.
2. It uses a `ThreadLocal` to store the current `tenant_id`.
3. It provides static methods (`setCurrentTenantId`, `getCurrentTenantId`, `clear`) for managing the context.
4. The `EafPostgresEventStorageEngine` is refactored to use this `TenantContextHolder` to get the `tenant_id` for its database queries.
5. All code that initiates event processing (e.g., command handlers, query handlers) is updated to correctly set and clear the tenant context.

## Tasks / Subtasks

- [ ] **Task 1: Create TenantContextHolder Core Implementation** (AC: 1, 2, 3)
  - [ ] Create `TenantContextHolder.kt` in `libs/eaf-core/src/main/kotlin/com/axians/eaf/core/tenancy`
  - [ ] Implement thread-safe `ThreadLocal<String>` for tenant ID storage
  - [ ] Add static method `setCurrentTenantId(tenantId: String)`
  - [ ] Add static method `getCurrentTenantId(): String?` with null safety
  - [ ] Add static method `clear()` for cleanup
  - [ ] Add static method `requireCurrentTenantId(): String` that throws exception if no tenant set

- [ ] **Task 2: Enhanced Context Management** 
  - [ ] Implement `executeInTenantContext(tenantId: String, block: () -> T)` for scoped execution
  - [ ] Add coroutine support with `CoroutineContext.Element` for async operations
  - [ ] Create `TenantContext` data class to hold additional tenant metadata if needed
  - [ ] Implement context inheritance for child threads/coroutines
  - [ ] Add context validation and sanitization methods

- [ ] **Task 3: Integration with EafPostgresEventStorageEngine** (AC: 4)
  - [ ] Update all database queries in `EafPostgresEventStorageEngine` to include tenant_id filter
  - [ ] Modify `appendEvents()` to validate tenant context before persistence
  - [ ] Update `readEvents()` methods to filter by current tenant context
  - [ ] Add tenant validation in `storeSnapshot()` and snapshot retrieval
  - [ ] Ensure all token-based streaming respects tenant boundaries

- [ ] **Task 4: Spring Security Integration** (AC: 5)
  - [ ] Create `TenantContextSecurityFilter` extending `OncePerRequestFilter`
  - [ ] Extract tenant ID from JWT token claims or request headers
  - [ ] Set tenant context early in request processing chain
  - [ ] Clear tenant context in `finally` block for cleanup
  - [ ] Handle tenant context for async processing and background jobs

- [ ] **Task 5: Axon Framework Integration**
  - [ ] Create `TenantAwareCommandInterceptor` for command handling
  - [ ] Create `TenantAwareEventInterceptor` for event processing
  - [ ] Update all command handlers to set tenant context from command metadata
  - [ ] Update event handlers to preserve tenant context during processing
  - [ ] Integrate with Axon's `MessageDispatchInterceptor` chain

- [ ] **Task 6: Error Handling and Monitoring**
  - [ ] Add comprehensive logging for tenant context operations
  - [ ] Create custom exceptions (`TenantContextException`, `TenantNotSetException`)
  - [ ] Add metrics for tenant context hit/miss rates
  - [ ] Implement tenant context debugging utilities
  - [ ] Add health checks for tenant context integrity

## Dev Technical Guidance

- **Module Location**: `libs/eaf-core/src/main/kotlin/com/axians/eaf/core/tenancy/`
- **Dependencies Required**: Add to `libs/eaf-core/build.gradle.kts`:
  ```kotlin
  implementation(libs.kotlinx.coroutines.core)
  implementation(libs.spring.security.core)
  implementation(libs.spring.web)
  implementation(libs.micrometer.core)
  ```
- **Thread Safety**: Use `ThreadLocal.withInitial { null }` for safe initialization and memory management
- **Coroutine Support**: Implement `AbstractCoroutineContextElement` for proper context propagation in suspend functions
- **Security Integration**: Must integrate with existing `EafSecurityContextHolder` without causing conflicts
- **Performance**: ThreadLocal access should be optimized - consider caching in request scope where appropriate
- **Memory Management**: Ensure proper cleanup to prevent memory leaks in high-throughput scenarios
- **Multi-Tenancy Pattern**: Follow established EAF patterns for tenant isolation and data segregation
- **Hexagonal Architecture**: Place in `core/tenancy` as cross-cutting concern used by infrastructure adapters

## Testing Guidance

- **Objective**: Verify thread safety, proper context propagation, integration with security and Axon frameworks
- **Key Test Scenarios**:
  - **Unit Tests**:
    - Test basic tenant context set/get/clear operations
    - Verify thread isolation - different threads have independent contexts
    - Test null safety and exception handling for missing tenant context
    - Verify `executeInTenantContext` properly cleans up after execution
  - **Concurrency Tests**:
    - Multi-threaded access to tenant context with different tenants
    - Coroutine context propagation across suspend function calls
    - Context inheritance in async processing scenarios
    - Memory leak detection under high load
  - **Integration Tests**:
    - End-to-end tenant isolation in `EafPostgresEventStorageEngine`
    - Spring Security filter integration with JWT extraction
    - Axon command/event handler context preservation
    - Database query verification (all queries include tenant_id filter)
  - **Security Tests**:
    - Tenant context tampering prevention
    - Context isolation between concurrent requests
    - Proper cleanup prevents tenant data leakage
    - Authorization boundaries respected
- **Performance Tests**:
  - ThreadLocal access overhead measurement
  - Context switching performance under load
  - Memory usage with large numbers of concurrent tenants
- **Success Criteria**: 
  - 100% thread isolation - no tenant data bleeding between threads
  - All database operations automatically include tenant_id filtering
  - No memory leaks after 1M+ context operations
  - Context propagation works seamlessly with coroutines and async processing
- **Tools**: JUnit 5, MockK, Testcontainers, Spring Boot Test, Kotlinx Coroutines Test, VisualVM for memory profiling
