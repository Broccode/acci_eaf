# Story 4.1.4: Unit & Integration Testing for EventStorageEngine

## Status: To Do

## Story
- **As a** Developer
- **I want** to write comprehensive unit and integration tests for the `EafPostgresEventStorageEngine`
- **so that** I can verify its correctness, concurrency handling, and tenant isolation.

## Acceptance Criteria
1. Unit tests are created for `EafPostgresEventStorageEngine` using MockK to mock the `EafEventStoreSdk`.
2. Unit tests cover all public methods and verify correct mapping and exception translation logic.
3. Integration tests are created using Testcontainers to spin up a real PostgreSQL instance.
4. Integration tests verify the end-to-end event persistence and retrieval flow.
5. Integration tests include specific scenarios for optimistic concurrency conflicts and tenant data isolation.

## Tasks / Subtasks

- [ ] **Task 1: Unit Test Infrastructure Setup** (AC: 1)
  - [ ] Create `EafPostgresEventStorageEngineTest.kt` in test directory
  - [ ] Set up MockK for `EafEventStoreSdk`, `TenantContextHolder`, and `AxonEventMessageMapper`
  - [ ] Create test fixtures for `DomainEventMessage`, `StoredEvent`, and `TrackingToken` instances
  - [ ] Set up test data builders for consistent test event creation
  - [ ] Configure relaxed mocking to avoid MockK DSL matcher issues

- [ ] **Task 2: Core Method Unit Testing** (AC: 2)
  - [ ] Test `appendEvents()` method with various event types and metadata
  - [ ] Test `storeSnapshot()` with aggregate snapshots and proper delegation
  - [ ] Test `readEvents(identifier, firstSequenceNumber)` for aggregate loading scenarios
  - [ ] Test `readEvents(trackingToken, mayBlock)` for event streaming scenarios
  - [ ] Test `createTailToken()` and `createHeadToken()` token creation methods
  - [ ] Verify all method calls delegate correctly to `EafEventStoreSdk` with expected parameters

- [ ] **Task 3: Event Message Translation Testing**
  - [ ] Test bidirectional conversion: `DomainEventMessage â†” StoredEvent`
  - [ ] Verify metadata preservation (correlation data, timestamps, aggregate version)
  - [ ] Test serialization/deserialization of various event payload types
  - [ ] Test snapshot event vs domain event handling differences
  - [ ] Verify error scenarios in event translation (malformed JSON, missing fields)

- [ ] **Task 4: Exception Handling Unit Tests**
  - [ ] Test `OptimisticLockException` translation to `ConcurrencyException`
  - [ ] Test `SQLException` translation to appropriate Axon exceptions
  - [ ] Test tenant context validation failures
  - [ ] Verify proper exception wrapping preserves original cause and message
  - [ ] Test timeout scenarios and resource cleanup

- [ ] **Task 5: Integration Test Infrastructure Setup** (AC: 3)
  - [ ] Create `EafPostgresEventStorageEngineIntegrationTest.kt`
  - [ ] Set up Testcontainers PostgreSQL with EAF event store schema
  - [ ] Configure Spring Boot test context with real `EafEventStoreSdk`
  - [ ] Set up test data for multiple tenants and aggregates
  - [ ] Create integration test base class for reusable setup

- [ ] **Task 6: End-to-End Integration Testing** (AC: 4)
  - [ ] Test complete event persistence and retrieval lifecycle
  - [ ] Verify Axon `TrackingEventProcessor` integration with custom tokens
  - [ ] Test event streaming with large volumes of events
  - [ ] Verify snapshot storage and aggregate reconstruction
  - [ ] Test event replay scenarios and processor reset functionality

- [ ] **Task 7: Concurrency and Tenant Isolation Testing** (AC: 5)
  - [ ] Test optimistic concurrency conflicts with parallel event appending
  - [ ] Verify tenant data isolation - events from Tenant A not visible to Tenant B
  - [ ] Test concurrent event streaming from different tenants
  - [ ] Verify proper tenant context handling in multi-threaded scenarios
  - [ ] Test database transaction boundaries and rollback scenarios

- [ ] **Task 8: Performance and Load Testing**
  - [ ] Benchmark event append throughput vs direct SDK usage
  - [ ] Test memory usage during large event streaming operations
  - [ ] Verify performance with 1M+ events in event store
  - [ ] Test garbage collection impact during sustained load
  - [ ] Compare performance against Axon's default implementations

## Dev Technical Guidance

- **Test Module Location**: `libs/eaf-eventsourcing-sdk/src/test/kotlin/com/axians/eaf/eventsourcing/axon/`
- **Dependencies Required**: Add to `libs/eaf-eventsourcing-sdk/build.gradle.kts`:
  ```kotlin
  testImplementation(libs.junit.jupiter)
  testImplementation(libs.mockk)
  testImplementation(libs.spring.boot.starter.test)
  testImplementation(libs.testcontainers.postgresql)
  testImplementation(libs.testcontainers.junit.jupiter)
  testImplementation(libs.axon.test)
  testImplementation(libs.kotlinx.coroutines.test)
  ```
- **MockK Configuration**: Use relaxed mocking and specific imports to avoid compilation issues
- **Test Data Strategy**: Create realistic event payload objects that mirror actual domain events
- **Integration Test Pattern**: Follow EAF integration test patterns with `@SpringBootTest` and proper profiles
- **Testcontainers Setup**: Use PostgreSQL 15-alpine with EAF event store schema pre-loaded
- **Tenant Test Data**: Use consistent tenant IDs (`TENANT_A`, `TENANT_B`) matching NATS configuration
- **Performance Baselines**: Establish performance SLAs (e.g., <10ms event append, <50ms for 1000 event stream)
- **Test Coverage Target**: Aim for >95% line coverage with meaningful assertion coverage

## Testing Guidance

- **Objective**: Ensure bullet-proof reliability, performance, and security of the critical EventStorageEngine adapter
- **Key Test Scenarios**:
  - **Unit Test Categories**:
    - **Happy Path**: All methods work correctly with valid inputs
    - **Error Handling**: Proper exception translation and error propagation
    - **Edge Cases**: Null inputs, empty collections, boundary conditions
    - **Mocking Verification**: Exact delegation calls with correct parameters
  - **Integration Test Categories**:
    - **Data Persistence**: Events stored and retrieved correctly
    - **Multi-Tenancy**: Complete tenant isolation verification
    - **Concurrency**: Optimistic locking and parallel access handling
    - **Performance**: Throughput and latency under realistic loads
  - **Load Test Scenarios**:
    - 10,000 events/second append rate sustainability
    - Event streaming with 1M+ event backlog
    - 100 concurrent TrackingEventProcessor instances
    - Extended runs (24h+) for memory leak detection
- **Success Criteria**: 
  - 100% test success rate across all scenarios
  - No tenant data leakage in isolation tests
  - Performance meets or exceeds established SLAs
  - Memory usage remains stable under sustained load
  - All exception scenarios handled gracefully
- **Failure Scenarios to Test**:
  - Database connection failures and recovery
  - Tenant context corruption or missing context
  - Event serialization/deserialization failures
  - Transaction rollback and cleanup scenarios
- **Tools**: JUnit 5, MockK, Spring Boot Test, Testcontainers, Axon Test Framework, JMH for benchmarking
